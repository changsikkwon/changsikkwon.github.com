var store = [{
        "title": "JSX",
        "excerpt":"JSX   const hi = &lt;p&gt;Hi&lt;/p&gt;;   위의 문법은 JSX라고 불리는 JS 확장버전이다. syntax extension for JS라고 한다. HTML과 아주 비슷하게 생겼고 JS 파일 내에서 작성할 수 있다.   JSX는 원래의 JS 문법이 아니기 때문에, JS 파일내에 JSX 문법이 있으면 브라우저에서 해석하지 못한다.   React.js를 사용하기 위해 JSX 문법이 포함되어 있으면, 해당 파일을 정규 JS 문법으로 변환시키는 컴파일 과정이 필요하다.   JSX element   const hi = &lt;p&gt;Hi&lt;/p&gt;;  const myFavorite = {     food: &lt;li&gt;샐러드&lt;/li&gt;,     animal: &lt;li&gt;dog&lt;/li&gt;,     hobbyL: &lt;li&gt;programming&lt;/li&gt;, };   JSX attribute   태그에 속성을 주고 싶을 때는 항상 ““로 감싸야한다.   예를 들어, class를 주고 싶을 때 원래 속성명은 class이지만 JSX에서는 className을 사용해야 한다.   const hi = &lt;input readOnly={true} /&gt;;  const myFavorite = {     food: &lt;li&gt;샐러드&lt;/li&gt;,     animal: &lt;li&gt;dog&lt;/li&gt;,     hobby: &lt;li className=\"list-item\"&gt;programming&lt;/li&gt;, };   Self-Closing Tag   JSX에서는 어떤 태그라도 self closing tag가 항상 가능하다. &lt;input&gt;과 같이 하나의 태그가 요소인 경우에는 &lt;input /&gt;과 같이 항상 /로 끝내줘야한다.   Nested JSX   중첩된 요소로 만들려면 ()로 감싸야한다.   const good = (     &lt;div&gt;         &lt;p&gt;hi&lt;/p&gt;     &lt;/div&gt; );   위와 같이 제일 처음 요소가 sibling이면 안된다. 무조건 하나의 태그로 감싸저야 한다.   const wrong = ( &lt;p&gt;list1&lt;/p&gt; &lt;p&gt;list2&lt;/p&gt; ); // 잘못된 코드   const right = (     &lt;div&gt;         &lt;p&gt;list1&lt;/p&gt;         &lt;p&gt;list2&lt;/p&gt;     &lt;/div&gt; ); // 맞는 코드   Rendering   html 요소, 또는 React 요소 등의 코드가 눈으로 볼 수 있도록 그려지는 것을 Rendering 이라고 말한다.   React 요소가 DOM node에 추가되어 화면에 렌더되려면 ReactDOM.render 함수를 사용한다.   첫 번째 인자에는 JSX로 React 요소를 인자로 넘기고, 두 번째 인자는 해당 요소를 렌더하고 싶은 container를 전달한다.   ReactDOM.render( \t&lt;h1&gt;Hello, world!&lt;/h1&gt; \tdocument.getElementbyID('root') );  ","categories": ["React"],
        "tags": ["React"],
        "url": "/react/JSX/",
        "teaser": null
      },{
        "title": "Linux",
        "excerpt":"Linux는 1991년 Linus Tovals가 개발한 운영체제 이다. Linux는 오픈소스이며 누구나 코드를 볼 수 있다.   Linux는 시스템을 운영하는데 가장 널리 사용되는 운영체제이다. Windows 시스템이나 application이 아닌 일반적으로 시스템 서버는 Linux 기반으로 운영되고있다.   Linux는 Windows처럼 일반인을 위한 운영체제가 아니기 때문에 익숙치 않으면 Linux 사용이 많이 어려울 수 있다.      Linux Directory Structure   PATH   Configs   Shell Commands   Linux File System Hierarchy (FHS)   Linux의 파일 구조는 다음과 같은 tree 형태로 되어있다.      FHS의 가장 위에는 / 디렉토리가 있다. Root 디렉토리라고 한다.시작점인 root 디렉토리 안에 여러 하위 디렉토리들이 있고 각 하위 디렉토리들 안에 또 하위 디렉토리 들이 있는 식이다. 각 디렉토리들은 /로 구분한다.   Home Directory   Linux file system에는 여러 디렉토리가 있지만 그 중 가장 중요하고 기본이 되는 디렉토리는 바로 home 디렉토리이다. 왜냐하면 home 디렉토리가 유저의 공간이기 때문이다.      Mac에서는 /home 디렉토리가 아니라 /Users 디렉토리에 유저의 home 디렉토리가 있다.   Path   디렉토리 경로에는 2가지 유형이 있는데 absolute path와 relative path이다.   Absolute Path   이름 그대로 절대경로이다. Absolute Path는 root 디렉토리에서 부터 시작하는 경로를 뜻한다.root 디렉토리에서 부터 시작하기 때문에 현재 나의 위치아 상관없이 항상 정확히 해당 경로로 이동 할 수 있다.   Relative Path   이름 그대로 상대경로이다. absolute path와는 다르게 현재 내 위치를 기반으로 움직이는 경로이다.경로를 이야기 할 때 .은 현재 디렉토리를 이야기한다.   ..은 현재 디렉토리의 상위 디렉토리를 의미한다.   Configs   Config fileLinux에는 설정을 주로 파일을 통해서 한다. 그리고 여러 config file, 즉 여러 설정 파일들이 있다. 그 중 가장 중요한 설정 파일이 바로 shell 설정 파일이다. 각 shell마다 고유 설정 파일이 있다. Bash는 .bashrc 라는 설정 파일을 사용하고 zsh는 .zshrc라는 설정 파일을 사용한다.   Shell Commands   Basic Shell Commands      cd = 해당 경로로 이동   ls = 현재 디렉토리 안의 파일 목록을 보여줌   mv = 원본이동   cp = 원본복사   cat = 파일 여러개의 내용을 화면에 출력할 때 이용   more = 파일을 읽어 화면에 화면 단위로 끊어서 출력   less = 한 번에 보여지는 만큼만 읽어서 출력하기 때문에 대용량의 파일을 열어 볼 때 빠르게 사용   tail = 파일의 내용을 뒤에서부터 출력   nohup = 터미널이 끊겨도 실행한 프로세스는 계속 동작하게 한다.   rm = 원복 삭제   mkdir = 폴더 생성   touch = 파일 생성   kill = 프로세서 강제종료   clear = 지난 화면 지우기   pwd = 현재 디렉토리 경로를 표시   chown = 파일의 owner 또는 group을 변경   chmod = 대상 파일과 디렉토리의 사용권한을 변경할 때 사용   grep = 파일 안 내용찾기   history = 그동안 사용자가 입력한 모든 터미널 명령어를 보여줌   ps = 현재 실행중인 모든 프로세서 표시   piping      |            pipe라고한다.       pipe는 일반적인 명령어가 아니라 명령어를 이어주는 역할을 한다.          ","categories": ["Os"],
        "tags": ["Os"],
        "url": "/os/Linux/",
        "teaser": null
      },{
        "title": "Os란?",
        "excerpt":"Operating System의 약자로 사용자가 컴퓨터를 쉽게 다룰 수 있게 해주는 인터페이스이다.  개인뿐 아니라 업무용 서버 등의 컴퓨터를 관리하고 제어하며, 컴퓨터를 작동시키기 위한 토대를 만드는 소프트웨어를 말한다.   OS의 종류   OS의 종류에는 Window, UNIX, LINUX, MS-DOS등이 있다.  단일 작업 처리 시스템에는 DOS, 다중 작업 처리 시스템에는 Windows, UNIX, LINUX등이 사용된다.  주로 Windows는 개인용 UNIX, LINUX는 서버용 운영체제로 사용된다.   OS의 목적   OS의 목적에는 처리능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등이 있다.  처리능력, 반환시간, 사용가능도, 신뢰도는 OS의 성능을 평가하는 기준이 된다.           처리능력       일정 시간 내에 시스템이 처리하는 일의 양            반환시간       시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간            사용가능도       시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도            신뢰도       시스템이 주어진 문제를 정확하게 해결하는 정도       OS의 기능      프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원을 관리한다.   자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공한다.   사용자와 시스템간의 편리한 인터페이스를 제공한다.   시스템의 각종 하드웨어와 네트워크를 관리, 제어한다.   데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공한다.   시스템의 오류를 검사하고 복구한다.   자원 보호 기능을 제공한다.   입출력에 대한 보조 기능을 제공한다.   가상 계산기 능력을 제공한다.   OS의 주요 자원관리      프로세스 관리            프로세스 스케줄링 및 동기화 관리담당       프로세스 생성과 제거, 시작과 정지, 메세지 전달등의 기능 담당                기억장치 관리       프로세스에게 메모리 할당 및 회수 관리 담당            주변장치 관리       입출력 장치 스케줄링 및 전반적인 관리 담당            파일 관리       파일의 생성과 삭제, 변경, 유지 등의 관리 담당      ","categories": ["Os"],
        "tags": ["Os"],
        "url": "/os/what-is-os/",
        "teaser": null
      }]
