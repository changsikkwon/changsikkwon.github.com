var store = [{
        "title": "JSX",
        "excerpt":"JSX   const hi = &lt;p&gt;Hi&lt;/p&gt;;   위의 문법은 JSX라고 불리는 JS 확장버전이다. syntax extension for JS라고 한다. HTML과 아주 비슷하게 생겼고 JS 파일 내에서 작성할 수 있다.   JSX는 원래의 JS 문법이 아니기 때문에, JS 파일내에 JSX 문법이 있으면 브라우저에서 해석하지 못한다.   React.js를 사용하기 위해 JSX 문법이 포함되어 있으면, 해당 파일을 정규 JS 문법으로 변환시키는 컴파일 과정이 필요하다.   JSX element   const hi = &lt;p&gt;Hi&lt;/p&gt;;  const myFavorite = {     food: &lt;li&gt;샐러드&lt;/li&gt;,     animal: &lt;li&gt;dog&lt;/li&gt;,     hobbyL: &lt;li&gt;programming&lt;/li&gt;, };   JSX attribute   태그에 속성을 주고 싶을 때는 항상 ““로 감싸야한다.   예를 들어, class를 주고 싶을 때 원래 속성명은 class이지만 JSX에서는 className을 사용해야 한다.   const hi = &lt;input readOnly={true} /&gt;;  const myFavorite = {     food: &lt;li&gt;샐러드&lt;/li&gt;,     animal: &lt;li&gt;dog&lt;/li&gt;,     hobby: &lt;li className=\"list-item\"&gt;programming&lt;/li&gt;, };   Self-Closing Tag   JSX에서는 어떤 태그라도 self closing tag가 항상 가능하다. &lt;input&gt;과 같이 하나의 태그가 요소인 경우에는 &lt;input /&gt;과 같이 항상 /로 끝내줘야한다.   Nested JSX   중첩된 요소로 만들려면 ()로 감싸야한다.   const good = (     &lt;div&gt;         &lt;p&gt;hi&lt;/p&gt;     &lt;/div&gt; );   위와 같이 제일 처음 요소가 sibling이면 안된다. 무조건 하나의 태그로 감싸저야 한다.   const wrong = ( &lt;p&gt;list1&lt;/p&gt; &lt;p&gt;list2&lt;/p&gt; ); // 잘못된 코드   const right = (     &lt;div&gt;         &lt;p&gt;list1&lt;/p&gt;         &lt;p&gt;list2&lt;/p&gt;     &lt;/div&gt; ); // 맞는 코드   Rendering   html 요소, 또는 React 요소 등의 코드가 눈으로 볼 수 있도록 그려지는 것을 Rendering 이라고 말한다.   React 요소가 DOM node에 추가되어 화면에 렌더되려면 ReactDOM.render 함수를 사용한다.   첫 번째 인자에는 JSX로 React 요소를 인자로 넘기고, 두 번째 인자는 해당 요소를 렌더하고 싶은 container를 전달한다.   ReactDOM.render( \t&lt;h1&gt;Hello, world!&lt;/h1&gt; \tdocument.getElementbyID('root') );  ","categories": ["React"],
        "tags": ["React"],
        "url": "/react/JSX/",
        "teaser": null
      },{
        "title": "Linux",
        "excerpt":"Linux는 1991년 Linus Tovals가 개발한 운영체제 이다. Linux는 오픈소스이며 누구나 코드를 볼 수 있다.   Linux는 시스템을 운영하는데 가장 널리 사용되는 운영체제이다. Windows 시스템이나 application이 아닌 일반적으로 시스템 서버는 Linux 기반으로 운영되고있다.   Linux는 Windows처럼 일반인을 위한 운영체제가 아니기 때문에 익숙치 않으면 Linux 사용이 많이 어려울 수 있다.      Linux Directory Structure   PATH   Configs   Shell Commands   Linux File System Hierarchy (FHS)   Linux의 파일 구조는 다음과 같은 tree 형태로 되어있다.      FHS의 가장 위에는 / 디렉토리가 있다. Root 디렉토리라고 한다.시작점인 root 디렉토리 안에 여러 하위 디렉토리들이 있고 각 하위 디렉토리들 안에 또 하위 디렉토리 들이 있는 식이다. 각 디렉토리들은 /로 구분한다.   Home Directory   Linux file system에는 여러 디렉토리가 있지만 그 중 가장 중요하고 기본이 되는 디렉토리는 바로 home 디렉토리이다. 왜냐하면 home 디렉토리가 유저의 공간이기 때문이다.      Mac에서는 /home 디렉토리가 아니라 /Users 디렉토리에 유저의 home 디렉토리가 있다.   Path   디렉토리 경로에는 2가지 유형이 있는데 absolute path와 relative path이다.   Absolute Path   이름 그대로 절대경로이다. Absolute Path는 root 디렉토리에서 부터 시작하는 경로를 뜻한다.root 디렉토리에서 부터 시작하기 때문에 현재 나의 위치아 상관없이 항상 정확히 해당 경로로 이동 할 수 있다.   Relative Path   이름 그대로 상대경로이다. absolute path와는 다르게 현재 내 위치를 기반으로 움직이는 경로이다.경로를 이야기 할 때 .은 현재 디렉토리를 이야기한다.   ..은 현재 디렉토리의 상위 디렉토리를 의미한다.   Configs   Config fileLinux에는 설정을 주로 파일을 통해서 한다. 그리고 여러 config file, 즉 여러 설정 파일들이 있다. 그 중 가장 중요한 설정 파일이 바로 shell 설정 파일이다. 각 shell마다 고유 설정 파일이 있다. Bash는 .bashrc 라는 설정 파일을 사용하고 zsh는 .zshrc라는 설정 파일을 사용한다.   Shell Commands   Basic Shell Commands      cd = 해당 경로로 이동   ls = 현재 디렉토리 안의 파일 목록을 보여줌   mv = 원본이동   cp = 원본복사   cat = 파일 여러개의 내용을 화면에 출력할 때 이용   more = 파일을 읽어 화면에 화면 단위로 끊어서 출력   less = 한 번에 보여지는 만큼만 읽어서 출력하기 때문에 대용량의 파일을 열어 볼 때 빠르게 사용   tail = 파일의 내용을 뒤에서부터 출력   nohup = 터미널이 끊겨도 실행한 프로세스는 계속 동작하게 한다.   rm = 원복 삭제   mkdir = 폴더 생성   touch = 파일 생성   kill = 프로세서 강제종료   clear = 지난 화면 지우기   pwd = 현재 디렉토리 경로를 표시   chown = 파일의 owner 또는 group을 변경   chmod = 대상 파일과 디렉토리의 사용권한을 변경할 때 사용   grep = 파일 안 내용찾기   history = 그동안 사용자가 입력한 모든 터미널 명령어를 보여줌   ps = 현재 실행중인 모든 프로세서 표시   piping      |            pipe라고한다.       pipe는 일반적인 명령어가 아니라 명령어를 이어주는 역할을 한다.          ","categories": ["Os"],
        "tags": ["Os"],
        "url": "/os/Linux/",
        "teaser": null
      },{
        "title": "Os란?",
        "excerpt":"Operating System의 약자로 사용자가 컴퓨터를 쉽게 다룰 수 있게 해주는 인터페이스이다.  개인뿐 아니라 업무용 서버 등의 컴퓨터를 관리하고 제어하며, 컴퓨터를 작동시키기 위한 토대를 만드는 소프트웨어를 말한다.   OS의 종류   OS의 종류에는 Window, UNIX, LINUX, MS-DOS등이 있다.  단일 작업 처리 시스템에는 DOS, 다중 작업 처리 시스템에는 Windows, UNIX, LINUX등이 사용된다.  주로 Windows는 개인용 UNIX, LINUX는 서버용 운영체제로 사용된다.   OS의 목적   OS의 목적에는 처리능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등이 있다.  처리능력, 반환시간, 사용가능도, 신뢰도는 OS의 성능을 평가하는 기준이 된다.           처리능력       일정 시간 내에 시스템이 처리하는 일의 양            반환시간       시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간            사용가능도       시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도            신뢰도       시스템이 주어진 문제를 정확하게 해결하는 정도       OS의 기능      프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원을 관리한다.   자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공한다.   사용자와 시스템간의 편리한 인터페이스를 제공한다.   시스템의 각종 하드웨어와 네트워크를 관리, 제어한다.   데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공한다.   시스템의 오류를 검사하고 복구한다.   자원 보호 기능을 제공한다.   입출력에 대한 보조 기능을 제공한다.   가상 계산기 능력을 제공한다.   OS의 주요 자원관리      프로세스 관리            프로세스 스케줄링 및 동기화 관리담당       프로세스 생성과 제거, 시작과 정지, 메세지 전달등의 기능 담당                기억장치 관리       프로세스에게 메모리 할당 및 회수 관리 담당            주변장치 관리       입출력 장치 스케줄링 및 전반적인 관리 담당            파일 관리       파일의 생성과 삭제, 변경, 유지 등의 관리 담당      ","categories": ["Os"],
        "tags": ["Os"],
        "url": "/os/what-is-os/",
        "teaser": null
      },{
        "title": "Array",
        "excerpt":"특징      가장 큰 특징은 순차적으로 데이터를 저장한다는 것이다.   주로 서로 연결된 데이터들을 순차적으로 저정할때 사용한다.   순서가 상관 없더라도 서로 연결된 데이터들을 저장할때 일반적으로 사용된다.   이미 생성된 리스트도 수정 가능하다.   동일한 값도 여러번 삽입 가능하다.   Multi-dimensional Array(다중차원 배열)이다.   내부구조      순서가 있다보니 당연하 순차적으로 번호를 지정할 수 있다. 이 번호를 index라고 한다.   index는 0부터 시작되며 마이너스 부호를 가질 수도 있다. 마이너스 index는 맨 마지막 요소부터 시작한다. 예를 들어 맨 마지막 요소의 index는 -1이다.   단점   1. Removing or Adding Elements   중간의 특정 요소를 삭제해야 하는 경우      순차적으로 담겨있는 데이터 중 특정 위치에 있는 중간의 요소가 삭제 되는 경우에, 항상 메모리가 순차적으로 이어져있어야 하기 때문에, 삭제된 요소로부터 뒤에 있는 모든 요소들을 앞으로 한칸씩 이동시켜주어야 한다.   그러므로 배열에서 요소를 삭제하는 것은 다른 자료구조에 비해 느릴 수 있다.   요소를 삭제하는 과정이 코드 상에서는 한 줄 이지만 실제 메모리 상에서 이루어지는 작업은 훨씬 커진다.   중간에 요소가 추가 되는 경우도 마찬가지이다. 특정 위치에 새롭게 요소가 추가되는 경우에는 그 뒤의 요소들이 하나씩 밀리게 된다.   그렇기 때문에 Array는 정보가 자주 삭제 되거나 추가되는 데이터를 담기에는 적절치 않다.   2. Array Resizing   배열은 메모리가 순차적으로 채워지기 때문에 배열이 처음 생성될 때 어느정도 메모리를 미리 할당한다.   메모리를 할당 함으로써 새로 추가되는 요소들도 순차적으로 메모리에 저장될 수 있다.   하지만 요소들이 처음 할당한 메모리 이상으로 많아지면 resizing이 필요하다.   즉 메모리를 추가 할당해야한다. 그리고 추가적으로 할당된 메모리 또한 순차적이어야 하기때문에 resizing은 오래걸리는 작업이다.   그렇기 때문에 Array는 사이즈 예측이 잘 안되는 데이터를 다루기에 적절치 않다.  ","categories": ["자료구조","Data Structure"],
        "tags": ["자료구조","Data Structure"],
        "url": "/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/array/",
        "teaser": null
      },{
        "title": "Component & Props",
        "excerpt":"Component   Component란 재사용 가능한 UI 단위이다.   컴포넌트는 함수랑 비슷하다. React 컴포넌트에서는 input을 Props라 말하고 return은 보여져야할 React요소가 return된다.   Component 만들기   함수로 컴포넌트 구현   function Welcome(props) {     return &lt;h1&gt;hello, {props.name}&lt;/h1&gt;; }   class로 컴포넌트 구현   class로 컴포넌트를 만들려면 React.Component 를 extend해서 생성한다. 컴포넌트를 생성할 때 render() 메서드는 무조건 정의해야하고, return도 해주어야한다.   class Welcome extends React.Component {     render() {         return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;     } }   Component 사용   function Welcome(props) {     return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; }  function App() {     return (         &lt;div&gt;             &lt;Welcome name=\"A\" /&gt;             &lt;Welcome name=\"B\" /&gt;             &lt;Welcome name=\"C\" /&gt;         &lt;/div&gt;     ); }  ReactDOM.render(&lt;App /&gt;, document.getElementByID('root'));  ","categories": ["React"],
        "tags": ["React"],
        "url": "/react/component-props/",
        "teaser": null
      },{
        "title": "Go 연산자",
        "excerpt":"산술연산자   산술연산자는 사칙연산자(+, -, *, /, % (Modulus))와 증감연산자(++, –)를 사용한다.   package main  import \"fmt\"  func main() {   a:=5   b:=10   c:=(a+b) / 5   fmt.Println(c) // 3 }   관계연산자   관계연산자는 서로의 크기를 비교하거나 동일함을 체크하는데 사용된다.   package main  import \"fmt\"  func main() {   a:=5   b:=10   fmt.Println(a==b) // false   fmt.Println(a!=b) // true   fmt.Println(a&lt;=b) // true }   논리연산자   논리연산자는 AND, OR, NOT을 표현하는데 사용된다.   A &amp;&amp; B A || !(C &amp;&amp; B)   Bitwise연산자   Bitwise연산자는 비트단위 연산을 위해 사용되는데, 바이너리 AND, OR, XOR과 바이너리 쉬프트 연산자가 있다.   package main  import \"fmt\"  func main() {   a:=3   b:=2   fmt.Printf(\"%08b\", a&amp;b) // 00000010   fmt.Printf(\"%08b\", a|b) // 00000011   fmt.Printf(\"%08b\", a^b) // 00000001 \tfmt.Printf(\"%08b\", a&lt;&lt;2)// 00001100 \tfmt.Printf(\"%08b\", a&lt;&lt;1)// 00000001 }   할당연산자   할당연산자는 값을 할당하는 = 연산자 외에 사칙연산, 비트연산을 축약한 +=, &amp;=, «= 같은 연산자들도 있다.   a = 100 a *= 10 a &gt;&gt;=2 a |= 1   포인터연산자   포인터연산자는 &amp;혹은 *을 사용하여 해당 변수의 주소를 얻어내거나 이를 반대로 Dereference 할 때 사용한다. Go는 비록 포인터연산자를 제공하지만 포인터 산술 즉 포인터에 더하고 빼는 기능은 제공하지 않는다.   package main  import \"fmt\"  func main() {   a:=10   p:=&amp;a // a의 주소를 할당   fmt.Println(*p) // p가 가르키는 주소에 있는 실제 내용출력 }  ","categories": ["Go"],
        "tags": ["Go"],
        "url": "/go/go-data-type/",
        "teaser": null
      },{
        "title": "Go 반복문",
        "excerpt":"for 문   Go 언어에서 반복문은 for 루프를 이용한다. Go는 반복문에 for 하나 밖에 없다. for 루프는 다른 언어와 비슷하게 “for 초기값; 조건식; 증감 {…}” 의 형식을 따른다.   package main  func main() { \tsum := 0 \tfor i := 1; i &lt;= 100; i++ { \t\tsum += i \t} \tprintln(sum) }   for 문 - 조건식만 쓰는 for 루프   Go에서 for 루프는 초기값과 증감식을 생략하고 조건식만을 사용할 수 있는데, 이는 마치 for 루프가 다른 언어의 while과 같이 쓰이도록 한다.   package main  func main() { \tn := 1 \tfor n &lt; 100 { \t\tn*=2 \t} \tprintln(n) }   for 문 - 무한루프   for 루프로 무한루프를 만들려면 “초기값; 조건식; 증감” 모두를 생략하면 된다.   package main  func main() { \tfor { \t\tprintln(\"Infinite loop\") \t} }   for range 문   for range 문은 컬렉션으로 부터 한 요소씩 가져와 차례로 for 블럭의 문장들을 실행한다.   for range 문은 “for 인덱스, 요소값 := range 컬렉션” 같이 for 루프를 구성하는데, range 키워드 다음의 컬렉션으로부터 하나씩 요소를 리턴해서 그 요소의 위치인덱스와 값을 for 키워드 다음의 2개의 변수에 각각 할당한다.   package main  func main() { \tnames := []string{\"홍길동\", \"김철수\", \"김영희\"}  \tfor index, name := range names { \t\tprintln(index, name) \t} }   break, continue, goto 문   경우에 따라 for 루프내에서 즉시 빠져나올 필요가 있는데, 이때 break 문을 사용한다. 만약 for 루프 중간에서 나머지 문장들을 실행하지 않고 for 루프 시작부분으로 바로 가려면 continue 문을 사용한다. 그리고 기타 임의의 문장으로 이동하기 위해 goto 문을 사용할 수 있다. goto 문은 for 루프와 관련없이 사용될 수 있다.   break 문은 for 루프 이외에 switch 문이나 select 문에서도 사용할 수 있다. 하지만, continue 문은 for 루프와 연관되어 사용된다.   package main  func main() { \ta := 1 \tfor a &lt; 15 { \t\tif a == 5 { \t\t\ta += a \t\t\tcontinue \t\t} \t\ta++ \t\tif a &gt; 10 { \t\t\tbreak \t\t} \t} \tif a == 11 { \t\tgoto END \t} \tprintln(a) END: \tprintln(\"END\") }   break 문은 보통 단독으로 사용되지만, 경우에 따라 “break 레이블”과 같이 사용하여 지정된 레이블로 이동할 수도 있다. break의 “레이블은” 보통 현재의 for 루프를 바로 위에 적게 되는데, 이러한 “break 레이블”은 현재의 로프를 빠져나와 지정된 레이블로 이동하고, break 문의 직속 for 로프 전체의 다음 문장을 실행하게 한다.   package main  func main() { \ti := 0  L1: \tfor { \t\tif i == 0 { \t\t\tbreak L1 \t\t} \t} \tprintln(\"OK\") }  ","categories": ["Go"],
        "tags": ["Go"],
        "url": "/go/go-for/",
        "teaser": null
      },{
        "title": "Go 조건문",
        "excerpt":"if 문   if문은 해당 조건이 맞으면 {} 블럭안의 내용을 실행한다. Go의 if 조건문은 괄호()로 둘러 싸지 않아도 된다. 그리고 반드시 조건 블럭 시작 {}를 if문과 같은 라인에 두어야한다.   그리고 한가지 주목할 점은 if문의 조건식은 반드시 Boolean식으로 표현되어야 한다는 것이다.   package main  import \"fmt\"  var k int = 1 func main() {   if k==1{     fmt.Println(\"one\") // one   } }   if문은 else if, 혹은 else문을 함께 가질 수 있다. else if문은 if 조건문이 거짓일 대 다시 다른 if 조건식을 검사하는데 사용되며, else문은 이전의 if 문들이 모두 거짓일 때 실행된다.   package main  import \"fmt\"  var k int = 1 func main() {   if k==1{     fmt.Println(\"one\") // one   } else if k==2{ \t\tfmt.Println(\"two\") // k가 2일경우 two \t} else{ \t\tfmt.Println(\"other\") // k가 1 혹은 2가 아닐경우 other \t} }   if문에서 조건식을 사용하기 이전에 간단한 문장을 함께 실행할 수 있다. 즉 아래 코드 처럼 a:= k+1 라는 문장을 조건식 이전에 실행할 수 있는데, 여기서 주의할 점은 이때 정의된 변수 a는 if문 블럭 scope 안에서만 사용할 수 있다는 것이다.   package main  import \"fmt\"  var k int = 1 var b int = 5 func main() {   if a:= k+1; a&lt;b {     fmt.Println(a) // 2   } }   switch 문   여러 값을 비교해야 하는 경우 혹은 다수의 조건식을 체크해야 하는 경우 switch 문을 사용한다. 다른 언어들과 비슷하게 switch 문 뒤에 하나의 변수를 지정하고, case 문에 해당 변수가 가질 수 있는 값들을 지정하여 각 경우에 다른 문장 블럭들을 실행할 수 있다.   package main  import \"fmt\"  func main() { \tvar name string \tvar number int = 1   switch number{ \tcase 1: \t\tname = \"John\" \tcase 2: \t\tname = \"Mike\" \tcase 3,4: \t\tname = \"Harry\" \tdefault: \t\tname = \"Nothing\" \t} \tfmt.Println(name) // John }   다음은 Go언어만의 특별한 switch 용법들이다.           switch 뒤에 표현이 없을 수 있음       다른 언어는 switch 키워드 뒤에 변수나 표현을 반드시 두지만, Go는 이를 쓰지 않아도 된다. 이 경우 Go는 switch 표현을 true로 생각하고 첫번째 case문으로 이동하여 검사한다.       case문에 표현을 쓸 수 있음 다른 언어의 case 문은 일반적으로 리터럴 값만을 갖지만, Go는 case문에 복잡한 표현을 가질 수 있다.        No default fall through       다른 언어의 case문은 break를 쓰지 않는 한 다음 case로 이동하지만, Go는 다음 case로 가지 않는다.            type switch       다른 언어의 switch는 일반적으로 변수의 값을 기준으로 case로 분기하지만, Go는 그 변수의 type에 따라 case로 분기할 수 있다.      ","categories": ["Go"],
        "tags": ["Go"],
        "url": "/go/go-if/",
        "teaser": null
      },{
        "title": "Go Data type",
        "excerpt":"데이터 타입   Go 프로그래밍 언어는 다음과 같은 기본적인 데이터 타입들을 갖고 있다.   제목 없음   문자열   문자열 리터럴은 Back Quote(``) 혹은 이중인용부호(“ “)를 사용하여 표현할 수 있다.      Back Quote로 둘러싸인 문자열은 Raw String Literal이라고 부르는데, 이 안에 있는 문자열은 별도로 해석되지 않고 Raw string 그대로의 값을 갖는다.   이중인용부호로 둘러싸인 문자열은 Interpreted String Literal이라 부르는데, 복수 라인에 걸쳐 쓸수 없으며, 인용부호 안의 escape 문자열들은 특별한 의미로 해석된다. 예를 들어, 문자열 안에 \\n 이 있을 경우 이는 NewLine으로 해석된다. 이중인용부호를 이용해 문자열을 여러 라인에 걸쳐 쓰기 위해서는 + 연산자를 이용해 결합하여 사용한다.   package main  import \"fmt\"  func main() { \t\t// Raw String Literal. 복수라인. \t\trawLiteral := `hello wolrd\\n hello wolrd\\n \thello wolrd`  \t\tinterLiteral := \"hello world\\nhello wolrd\" \t// or interLiteral := \"hello world\\n\" + \t//\t\t\t\t\t\t\t\t\t\t\"hello wolrd\"  \t\tfmt.Println(rawLiteral)     fmt.Println()     fmt.Println(interLiteral)  \t// 출력 hello world\\n hello world\\n   hello world  hello world hello world }   데이터 타입 변환   하나의 데이타 타입에서 다른 데이타 타입으로 변환하기 위해서는 T(v) 와 같이 표현하고 이를 Type Conversion이라 부르는데, 여기서 T는 변환하고자 하는 타입을 표시하고, v는 변환될 값(value)을 지정한 것이다. 예를 들어, 정수 100을 float로 변경하기 위하여 float32(100) 처럼 표현하고, 문자열을 바이트배열로 변경하기 위하여 []byte(“ABC”) 처럼 표현할 수 있다.   주의할 점은 Go에서 타입간 변환은 명시적으로 지정해 주어야 한다는 점인데, 예를 들어 정수형 int에서 uint로 변환할 때, 암묵적(implicit) 변환이 일어나지 않으므로 uint(i) 처럼 반드시 변환을 지정해 주어야 한다. 만약 명시적 지정이 없이 변환이 일어나면 런타임 에러가 발생한다.   func main() {     var i int = 100     var u uint = uint(i)     var f float32 = float32(i)     println(f, u)      str := \"ABC\"     bytes := []byte(str)     str2 := string(bytes)     println(bytes, str2) }  ","categories": ["Go"],
        "tags": ["Go"],
        "url": "/go/go-operator/",
        "teaser": null
      },{
        "title": "Go Print",
        "excerpt":"Go에서 표준출력 및 입력을 하기 위해선 fmt라는 패키지를 사용해야 한다. 기능에 따라 여러 print가 존재한다. 또한 데이터를 출력 및 받고자 할 때 데이터 타입에 따라 사용해야 하는 포맷이 다르기 때문에 확인을 하고 사용해야 합니다.   fmt.Fprint(OS)   print 앞에 F가 붙으면 파일 입출력에 해당한다. fprint는 파일에 쓰는 용도이다.   func Fprint, Fprintf, Fprintlin   Fprint // Fprint가 여러번 호출되도 한 줄로 이어서 파일에 쓰임 fmt.Fprint(파일, 파일에 쓰고자 하는 데이터)  Fprintln // Fprintln 여러번 호출될 때마다 마지막 줄에 줄넘김이 추가됨 fmt.Fprintln(파일, 파일에 쓰고자 하는 데이터)  Fprintf // Fprintf가 호출될 때마다 사용자가 추가한 구분자로 구분 fmt.Fprintf(파일, 파일에 쓰고자 하는 데이터)   fmt.Print(표준출력)   일반적으로 많이 사용하는 print에 대한 출력이다.   func Print, Printf, Println   Print // Print가 여러번 호출되도 한 줄로 이어서 출력 fmt.Print(\"Hello world\")  Println // Println가 여러번 호출되면 다음줄에 출력 fmt.Println(\"Hello world\")  Printf // Printf가 호출될 때마다 사용자가 추가한 포맷에 해당하여 입력된 변수값을 출력 fmt.Printf(포맷, 출력하고자 하는 데이터)   fmt.Sprint   사용법은 fmt.Print와 같지만 해당 문법을 사용하면 표준 출력을 하진 않는다. 해당 문법을 사용하는 경우는 출력되는 값을 string 타입으로 return 할 때 사용한다.   Sprint // Sprint가 여러번 호출되도 한 줄로 이어서 출력 fmt.Sprint(출력하고자 하는 데이터)  Sprintln // Sprintln가 여러번 호출되면 다음줄에 출력 fmt.Sprintln(출력하고자 하는 데이터)  Sprintf // Sprintf가 호출될 때마다 사용자가 추가한 포맷에 해당하여 입력된 변수값을 string 타입으로 출력 fmt.Printf(포맷, 출력하고자 하는 데이터)  ","categories": ["Go"],
        "tags": ["Go"],
        "url": "/go/go-print/",
        "teaser": null
      },{
        "title": "Go 변수와 상수",
        "excerpt":"변수   변수는 Go 키워드 var를 사용하여 선언한다. var 키워드 뒤에 변수명을 적고, 그 뒤에 변수 타입을 적는다.   var a int   변수 선언문에서 변수 초기값을 할당할 수도 있다.   var a int = 0 var b float32 = 11.0   일단 선언된 변수는 그 뒤의 문장에서 해당 타입의 값을 할당할 수 있다.   a = 10 f = 12.0   만약 선언된 변수가 Go 프로그램 내에서 사용되지 않는다면, 에러를 발생시킨다.   동일한 타입의 변수가 여러개 있을 경우, 변수들을 나열하고 마지막에 타입을 한번만 지정할 수 있다.   var a, b, c int   마찬가지로 복수 변수들이 선언된 상황에서 초기값을 지정할 수 있다. 초기값은 순서대로 변수에 할당된다.   var a, b, c int = 1, 2, 3   변수를 선언하면서 초기값을 지정하지 않으면, Go는 0을 기본적으로 할당한다.   숫자형에는 0, bool타입에는 false, string타입에는 ““(빈문자열)을 할당한다.   변수를 선언하는 또 다른 방식으로 Short Assignment Statement ( := ) 를 사용할 수 있다. var i =1을 쓰는 대신 i:=1 이라고 var를 생략하고 사용할 수 있다. 하지만 이러한 표현은 함수 내에서만 사용할 수 있고, 함수 밖에서는 var를 사용해야한다.   상수   상수는 Go 키워드 const를 사용하여 선언한다. const 키워드 뒤에 상수명을 적고, 그 뒤에 상수타입, 그리고 상수값을 할당한다.   const a int = 10 const b string = \"Hello world\"   Go에서는 할당되는 값을보고 그 타입을 추론하는 기능이 자주 사용된다. 위의 경우 타입 int, string을 생략하면 Go에서 자동으로 그 타입을 추론하게 된다.   const a = 10 const b = \"Hello world\"   여러 개의 상수들을 묶어서 지정할 수 있는데, 아래와 같이 괄호 안에 상수들을 나열하여 사용할 수 있다.   const ( \t\tHello = \"Hello\" \t\tworld = \"world\" \t\tGo = \"Go\" )   상수값을 0부터 순차적으로 부여하기 위해 iota라를 identifier를 사용할 수 있다.   const ( \t\ta = iota // 0 \t\tb        // 1 \t\tc        // 2 )   3. Go 키워드   Go 프로그래밍 언어는 다음과 같은 25개의 예약 키워드들을 갖는다. Go 키워드들은 변수명, 상수명, 함수명 등의 identifier로 사용할 수 없다.   break     default      func     interface   select case      defer        go       map         struct chan      else         goto     package     switch const     fallthrough  if       range       type continue  for          import   return      var  ","categories": ["Go"],
        "tags": ["Go"],
        "url": "/go/go-variable/",
        "teaser": null
      },{
        "title": "Go",
        "excerpt":"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성을 잘 지원하는 컴파일 언어이다. 구문이 C와 비슷하지만 메모리 보안, 가비지 컬렉션, 구조 타이핑, CSP 스타일 병행성을 제공한다. Go는 golang.org라는 도메인 이름 때문에 종종 golang으로도 호칭되지만 정확한 명칭은 Go이다.   2개의 주요 구현체가 있다. 하나는 구글의 셀프 호스팅 컴파일러 툴체인ㅇ로서 여러 운영 체제, 모바일 장치, 웹어셈블리를 대상으로 한다. 나머지 하나는 GCC프론트엔드인 gccgo가 있다.   서드파티 트랜트파일러 Gopher JS는 프론트 웹 개발을 위해 Go를 자바스크립트로 컴파일한다.   언어설계   Go의 문법은 대체로 C와 비슷하다. 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다. C와 다르게 한 라인 끝의 세미콜론은 필수가 아닌 옵션이다. 변수 선언은 다르게 작성되고 대게 옵션이다. 형 변환은 명시적으로 해야한다. 병행 컴퓨팅을 다루기 위해 go와 select 키워드가 사용횐다. 새로운 타입은 map, 유니코드 문자열, 배열 slice, 그리고 내부 쓰레드 통신을 위한 채널이 있다.   언어도구   Go는 수많은 언어 배포판들과 동일한 종류의 디버깅, 테스트, 코드 검사도구들을 포함하고 있다. 그 중에 Go 배포판은 다음을 포함한다.      go build: 소스 파일 자체의 정보만을 사용하여 Go 바이너리를 빌드한다. 별도의 makefile은 없다.   go test: 유닛 테스트 및 마이크로벤치마크   go fmt: 코드 서식 지정   go get: 원격 패키지의 검색 및 설치   go vet: 코드 내의 잠재적인 오류를 찾아내는 정적 분석기   go run: 코드를 빌드하고 실행하는 바로 가기   godoc: 문서를 표시. HTTP를 통해 문서 확인.   gorename: 변수, 함수 등을 형 안전(type-safe) 방식으로 이름 변경   go generate: 코드 생성기를 호출하는 표준 방식  ","categories": ["Go"],
        "tags": ["Go"],
        "url": "/go/go/",
        "teaser": null
      },{
        "title": "Iterator, Generator",
        "excerpt":"Iterator   list, set, dictionary와 같은 컬렉션이나 문자열과 같은 문자 Sequence 등은 for 문을 써서 하나씩 데이터를 처리할 수 있는데, 이렇게 하나하나 처리할 수 있는 컬렉션이나 Sequence 들을 Iterable 객체라 부른다.   for n in [1,2,3,4,5]:     print(n)  for c in \"Hello World\":    print(c)   내장 함수 iter()는 “iter(iterable객체)”와 같이 사용하여 그 Iterable 객체의 iterator를 리턴한다. Iterable 객체에서 실제 Iteration을 실행하는 것은 iterator로서, iterator는 next 메서드를 사용하여 다음 요소를 가져온다. 만약 더이상 next 요소가 없으면 StopIteration Exception을 발생시킨다.   Iterator의 next 메서드로서 Python2에서는 “iterator객체.next()”를 사용하고, python 3에서는 “iterator객체.next()” 메서드를 사용한다. 또한, 버전에 관계없이 사용할 수 있는 방식으로 내장 함수 “next(iterator객체)”를 사용할 수 있다.      어떤 클래스를 Iterable하게 하려면, 그 클래스의 iterator를 리턴하는 __iter__() 메서드를 작성해야 한다. 이 __iter__() 메서드를 리턴하는 iterator는 동일한 클래스 객체가 될 수도 있고, 별도로 작성된 iterator 클래스의 객채가 될 수도 있다. 어떠한 경우든 Iterator가 되는 클래스는 __next__() 메서드를 구현해야 한다. 실제 for 루프에 Iterable 객체를 사용하면, 해당 Iterable의 __iter__() 메서드를 호출하여 iterator를 가져온 후 그 iterator의 __next__() 메서드를 호출하여 루프를 돌게 된다.   class MyCollection:     def __init__(self):         self.size = 10         self.data = list(range(self.size))      def __iter__(self):         self.index = 0         return self      def __next__(self):         if self.index &gt;= self.size:             raise StopIteration          n = self.data[self.index]         self.index += 1         return n  for i in MyCollection():     print(i)   Generator   Generator는 iterator의 특수한 한 형태이다.   Generator 함수는 함수안에 yield를 사용하여 데이터를 하나씩 리턴하는 함수이다. Generator 함수가 처음 호출되면, 그 함수 실행 중 처음으로 만나는 yield에서 값을 리턴한다.   Generator 함수가 다시 호출되면, 직전에 실행되었던 yield문 다음부터 다음 yield문을 만날 때까지 문장들을 실행하게 된다. 이러한 Generator 함수를 변수에 할당하면 그 변수는 generator 클래스 객체가 된다.   def gen():     yield 1     yield 2     yield 3  g = gen() print(type(g)) # &lt;class 'generator'&gt;  n = g.__next__(); print(n) #1 n = g.__next__(); print(n) #2 n = g.__next__(); print(n) #3  #for 루프 사용 가능 for i in gen():     print(i)   list나 set과 같은 컬렉션에 대한 iterator는 해당 컬렉션이 이미 모든 값을 가지고 있는 경우이나, Generator는 모든 데이터를 갖지 않은 상태에서 yield에 의해 하나씩만 데이터를 만들어 가져온다는 차이점이 있다. 이러한 Generator는 데이터가 무제한이어서 모든 데이터를 리턴할 수 없는 경우나, 데이터가 대량이어서 일부러 처리하는 것이 필요한 경우, 혹은 모든 데이터를 미리 계산하면 속도가 느려서 그때그때 on demand로 처리하는 것이 좋은 경우 등에 종종 사용되나.   Generator Expression   Generator Expression은 Generator Comprehension으로도 불리는데, List Comprehension광 외관상 유사하다. List Comprehension은 앞뒤를 []처럼 대괄호로 표현한다면, Generator Comprehension은 ()처럼 둥근 괄호를 사용한다. 하지만 Generator Comprehension은 List Comprehension과 달리 실제 리스트 컬렉션 데이터 전체를 리턴하지 않고, 그 표현식만 갖는 Generator 객체만 리턴한다. 즉 실제 실행은 하지 않고, 표현식만 가지며 위의 yield 방식으로 Lazy Operation을 수행하는 것이다.   g = (n*n for n in range(1001))  print(type(g)) #&lt;class 'generator'&gt;  #리스트로 일괄 변환시 #mylist = list(g)  for i in range(10):     value = g.__next__()     print(value)  # 나머지 모두 출력 for i in g:     print(i)  ","categories": ["Python"],
        "tags": ["Python"],
        "url": "/python/iterator-generator/",
        "teaser": null
      },{
        "title": "NoSQL",
        "excerpt":"NoSQL      비관계형 타입의 데이터를 저장할때 주로 사용되는 데이터베이스 시스템   관계형 데이터베이스와 다르게 비관계형 이기 때문에 데이터들을 저장하기 전에 정의 할 필요가 없다.   MongoDB, Redis, Cassandra 등이 가장 대표적인 NoSQL 데이터 베이스이다.   SQL(RDBMS) VS NoSQL   SQL      장점            관계형 데이터베이스는 데이터를 더 효율적으로 그리고 체계적으로 저장할 수 있고 관리 할 수 있다.       미리 저장하는 데이터들의 구조(테이블 스키마)를 정의 함으로 데이터의 완전성이 보장된다.       트랜잭션(transaction)           단점            테이블을 미리 정의해야 함으로 테이블 구조 변화 등에 덜 유연하다.       테이블 구조가 미리 정의 되어 있다보니 단순히 서버를 늘리는것 만으로 확장 하기가 쉽지 않고 서버의 성능 자체도 높여야 한다.       정형화 된 데이터들 그리고 데이터의 완전성이 중요한 데이터들을 저장하는데 유리하다.           NoSQL      장점            데이터 구조를 미리 정의하지 않아도 됨으로 저장하는 데이터의 구조 변화에 유연하다.       확장하기가 비교적 쉽다. 그냥 서버 수를 늘리면 됨(scale out)       확장 하기가 쉽고 데이터의 구조도 유연하다 보니 방대한 양의 데이터를 저장하는데 유리하다.           단점            데이터의 완전성이 덜 보장된다.       트랜잭션이 안되거나 비교적 불안정하다.          ","categories": ["Database"],
        "tags": ["Database"],
        "url": "/database/nosql/",
        "teaser": null
      },{
        "title": "RDBMS",
        "excerpt":"RDBMS(관계형 데이터베이스)      이름 그대로, 관계형 데이터 모델에 기초를 둔 데이터베이스 시스템을 말한다.   관계형 데이터란 데이터를 서로 상호관련성을 가진 형태로 표현한 데이터를 말한다.            모든 데이터들은 2차원 테이블(table)들로 표현 된다.       각각의 테이블은 컬럼(column)과 row(로우)로 구성된다.       각각의 테이블들은 서로 상호관련성을 가지고 서로 연결될 수 있다.                    테이블끼리의 연결에는 크게 3종류가 있다                            one to one               one to many               many to many                                                   Why connect the tables?      하나의 테이블에 모든 정보를 다 넣으면 동일한 정보들이 불필요하게 중복되어 저장된다.더 많은 디스크를 사용하게되고 잘못된 데이터가 저장 될 가능성이 높아진다.   여러 테이블에 나누어서 저장한 후 필요한 테이블끼리 연결 시키면 위의 2문제가 사라진다. 중복된 데이터를 저장하지 않음으로 디스크를 더 호율적으로 쓰고, 또한 서로 같은 데이터 이지만 부분적으로 틀린 데이터가 생기는 문제가 없어진다. 이것을 normalization(정규화) 이라고 한다.   ACID      원자성(Atomicity)은 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. 예를 들어, 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 빼 오는 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다. 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.   일관성(Consistency)은 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.   고립성(Isolation)은 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다. 은행 관리자는 이체 작업을 하는 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽을 볼 수 없다. 공식적으로 고립성은 트랜잭션 실행내역은 연속적이어야 함을 의미한다. 성능관련 이유로 인해 이 특성은 가장 유연성 있는 제약 조건이다. 자세한 내용은 관련 문서를 참조해야 한다.   지속성(Durability)은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다. 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.   트랜잭션      ACID를 제공함으로 따라서 트랜잭션(일련의 작업들을 한번에 하나의 unit으로 실행하는것) 기능을 제공한다.            트랜잭션은 일련의 작업들이 마치 하나의 작업처럼 취급되어서 모두 다 성공하거나 아니면 모두 다 실패하는걸 이야기 한다.          ","categories": ["Database"],
        "tags": ["Database"],
        "url": "/database/rdbms/",
        "teaser": null
      },{
        "title": "Set, Dictionary, Hash",
        "excerpt":"Set   set는 list처럼 순열 자료구조이다. 하지만 set는 순서라는 개념이 존재하지 않는다.   특징      데이터를 비순차적으로 저장할 수 있는 순열 자료구조이다.   삽입 순서대로 저장되지 않는다.   수정가능하다.   동일한 값을 여러번 삽입 불가능하다. 동일한값이 여러번 삽입 되면 하나의 값만 저장된다.   Fast Lookup이 필요할 때 주로 쓰인다.   구조         set요소들이 저장될 때 순서는 다음과 같다.            저장할 요소읙 값의 hash 값을 구한다.       hash값에 해당하는 공간(bucket)에 값을 저장한다.           이렇게 set는 저장하고자 하는 값의 해쉬값에 해당하는 bucket에 값을 저장하기 때문에 순서가 없다. 순서가 없기 때문에 indexing도 없다.   hash값을 기반으로 저장하기 때문에 look up이 굉장히 빠르다.   Dictionary   Dictionary는 key-value 형태의 값을 저장할 수 있는 자료구조이다.   특징      set와 마찬가지로 특정 순서대로 데이터를 리턴하지 않는다.   key의 값은 중복될수 없다.(만일 중복된 key가 있으면 먼저 있던 key와 value를 대체한다.)   수정 가능하다.   구조         set와 비슷하게 key값의 hash값을 구한 후 hash값에 속해있는 bucket에 값을 저장한다.   Hash   hash란 단 방향 암호화이다. 입력 데이터를 변환하여 원본 데이터로 복호화할 수 없도록 하는 과정이다.  ","categories": ["자료구조","Data Structure"],
        "tags": ["자료구조","Data Structure"],
        "url": "/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/set-dictionary-hash/",
        "teaser": null
      },{
        "title": "Stack & Queue",
        "excerpt":"Stack   stack은 LIFO(Last In First Out)라고 한다. 마지막으로 저장한 데이터가 처음으로 읽힌다는 뜻이다.         Stack에서 데이터 저장은 push라고 한다.   데이터를 읽어들이는 건 pop라고 한다. 다만 pop은 읽어들임과 동시에 stack에서 삭제한다.   리스트를 사용한 Stack 구현 예제   class Stack:    def __init__(self):      self._stack = []     def push(self, data):      self._stack.append(data)     def pop(self):      if len(self._stack) == 0:        return None       data = self._stack[-1]      del self._stack[-1]       return data     def peek(self):      if len(self._stack) == 0:        return None       data = self._stack[-1]       return data   Queue   Stack과 반대로 FIFO(First In First Out)이다. 즉 먼저 push 된게 먼저 pop된다는 말이다.      리스트를 사용한 Queue 구현 예제   class Queue:     def __init__(self):         self._queue = []      def push(self, data):         return self._queue.append(data)      def pop(self)         if len(self._queue) == 0:             return None          return self._queue.pop()      def peek(self):         if len(self._queue) == 0:             return None          return self[0]  ","categories": ["자료구조","Data Structure"],
        "tags": ["자료구조","Data Structure"],
        "url": "/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/stack-queue/",
        "teaser": null
      },{
        "title": "Component의 State",
        "excerpt":"State   state란 말 그대로 컴포넌트의 상태 값이다.   state와 props는 둘 다 object 이고, 화면에 보여줄 정보를 가지고 있다는 점에서 서로 비슷한 역할을 한다. props는 컴포넌트를 사용하는 부모쪽에서 전달해야만 사용할 수 있고, state는 컴포넌트 내에서 정의하고 사용한다.   class Button extends React.Component {     constructor() {         super();          this.state = {             clicked: flase,         };     }      render() {         return (             &lt;div                 className=\"btn\"                 onClick={() =&gt; {                     this.setState({ clicked: !this.state.clicked });                 }}             &gt;                 {this.state.clicked ? '좋아요' : '싫어요'}             &lt;/div&gt;         );     } }  ReactDom.render(&lt;Button /&gt;, document.getElementByID('root'));   onClick={()=&gt;{this.setState({ clicked: !this.state.clicked })}}      click하면 clicked라는 state를 수정한다. this.setState() 함수로 state를 업데이트 할 수 있다.   !this.state.clicked 로 업데이트 한다는 말은 현재 clicked의 반대로 저장한다는 말이다.   {this.state.clicked ? ‘좋아요’ : ‘싫어요’}      clicked staterk true면 ‘좋아요’를 보여주고 false면 ‘싫어요’를 보여준다.   constructor()   constructor는 class의 인스턴스가 생성될 때 항상 호출되는 함수이다. 초기화할 값들을 constructor에서 세팅해준다고 보면 된다.   constructor() { \t\tsuper();  \t\tthis.state = { \t\t\tclicked: flase \t}   Button 컴포넌트를 그리려면 this.state.clicked 값이 필요한데, 제일 최초에는 값이 없으므로 constructor에서 값을 지정해준다.   super() 라는 키워드를 꼭 작성해야 React.Component class에 있는 메서드를 사용할 수 있다.  ","categories": ["React"],
        "tags": ["React"],
        "url": "/react/state/",
        "teaser": null
      },{
        "title": "Tree",
        "excerpt":"Tree      Tree는 일반적으로 대상 정보의 각 항목들을 계층적으로 연관되도록 구조화 시키고자 할 때 사용하는 비선형 자료구조이다.   데이터 요소들의 단순한 나열이 아닌 부모 - 자식 관곅의 계층적 구조로 표현된다.   Tree는 그래프의 한 종류이며 사이클이 없다.   Tree 자료구조는 여러유형이 있지만 그 중 가장 기본은 binary tree 구조가 대표적이다.   binary tree는 두개의 자식노드를 가진 트리 형태이다.   Tree의 자료구조는 데이터를 거꾸로된 나무 형태로 저장하는 모양이다.   계층적인 관계의 표현에 쓰이고, 윈도우와 리눅스의 파일시스템 구조도 Tree로 표현된다.   용어         Node : Tree구조의 교점이다. Node가 데이터를 가지고 있고 또한 자식노드를 가지고 있다. Tree 자료구조는 노드를 기본으로 구성된다.   Root Node: Tree구조의 가장 위 노드.   Edge: Tree를 구성하기 위해 노드와 노드를 연결하는 선이다.   level: Tree의 특정 깊이를 가지는 노드의 집합이다.   degree: 하위 Tree개수 / 각 노드가 지닌 가지의 수를 말한다.   Internal Node : Leaf노드를 제외한 중간에 위치한 노드들을 말한다.   Leaf Node: 하위에 다른 노드가 연결되어 있지 않은 노드이다.   Tree의 속성 중 가장 중요한 것이 ‘루트 노드를 제외한 모든 노드는 단 하나의 부모노드만을 가진다’는 것이다.   Tree의 탐색   Tree의 순회란 Tree의 각 노드를 체계적인 방법으로 방문하는 과정을 말한다.      전위순회(preorder)루트노드 - 왼쪽 서브Tree - 오른쪽 서브Tree 순으로 순회하는 방식이다.   중위순회(inorder)루트노드에서 시작해서 왼쪽 서브Tree - 노드 - 오른쪽 서브Tree 순으로 순회하는 방식이다.   후위순회(postorder)루트노드에서 시작해서 왼쪽 서브Tree - 오른쪽 서브Tree - 노드 순으로 순회하는 방식이다.  ","categories": ["자료구조","Data Structure"],
        "tags": ["자료구조","Data Structure"],
        "url": "/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/tree/",
        "teaser": null
      },{
        "title": "Tuple",
        "excerpt":"특징      List와 마찬가지로 데이터를 순차적으로 저장할 수 있는 순열 자료구조이다.   LIst와 다르게 한 번 정의되고 나면 수정할 수 없다.   2-3개 정도의 적은 수의 소규모 데이터를 저장할 때 많이 사용한다.   장점      List보다 더 가볍고 메모리를 적게 차지한다.   Tuple은 간단한 값을 빨리 표현하고 싶을때 많이 사용한다.            ex           // Tuple을 사용하는 경우 [(1,2), (2,4)] // Array(List) 안의 Tuple  // Tuple을 안 쓰는 경우에는 class를 생성해야함 class cord: \tdef __init__(self, x, y): \t\tself.x = x \t\tself.y = y   단점      Tuple의 데이터는 무슨 의미인지 명확하지 않다.   데이터의 의미를 문맥을 보고 가정해야한다.            예를들어 객체의 경우 key-value 쌍으로 이루어진 데이터이기 때문에 무슨 데이터인지 파악이 쉽지만, Tuple의 경우 괄호 안에 데이터만 담겨있기 때문에 문맥에 맞게 의미를 추측해야 한다.           Tuple을 사용하기 좋은 곳           List를 쓰기에는 간단한 데이터들을 표현할 때 사용한다.              ex) 좌표 데이터           coordinations = [     (1, 2),     (3, 4),     (5, 6) ]          ","categories": ["자료구조","Data Structure"],
        "tags": ["자료구조","Data Structure"],
        "url": "/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/tuple/",
        "teaser": null
      },{
        "title": "자료구조란?",
        "excerpt":"   자료구조란 데이터에 편리하게 접근하고 조작하기 위한 데이터를 저장하거나 조직하는 방법이다.   자료구조의 종류에는 여라가지가 있습니다. 하지만 모든 목적에 부합하는 자료구조는 없다. 따라서 각각의 자료구조가 갖는 장점과 한계를 잘 이해하고 상황에 맞게 올바른 자료구조를 선택하고 사용하는 것이 중요하다.   자료구조는 언어별로 지원하는 양상이 다르다.   각 언어가 가진 자료구조의 종류와 그것에 대한 사용 방법을 익히는 것이 중요하지만, 무엇보다 각 자료구조의 본질과 컨셉을 이해하고 상황에 맞는 적절한 자료 구조를 선택하는 것이 중요하다.   자료구조의 분류                  Primitive Data Structure(단순 구조)       프로그래밍에서 사용되는 기본 데이터 타입                       None-Primitive Data Structure(비단순 구조)       단순한 데이터를 저장하는 구조가 아니라 여러 데이터를 목적에 맞게 효과적으로 저장하는 자료 구조 - Linear Data Structure(선형 구조)       저장되는 자료의 전후 관계가 1:1 (ex. List, Stacks, Queues) - Non-Linear Data Structure(비선형 구조)       데이터 항목 사이의 관계가 1:n 또는 n:m (ex. Graphs, Trees )          ","categories": ["자료구조","Data Structure"],
        "tags": ["자료구조","Data Structure"],
        "url": "/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/what-is-data-structure/",
        "teaser": null
      }]
