<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://changsikkwon.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://changsikkwon.github.io/" rel="alternate" type="text/html" /><updated>2021-02-25T12:15:51+09:00</updated><id>https://changsikkwon.github.io/feed.xml</id><title type="html">Changsik’s Blog</title><subtitle>An amazing website.</subtitle><author><name>권창식</name><email>kcs15987@gmail.com</email></author><entry><title type="html">Array</title><link href="https://changsikkwon.github.io/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/array/" rel="alternate" type="text/html" title="Array" /><published>2021-02-25T00:00:00+09:00</published><updated>2021-02-25T00:00:00+09:00</updated><id>https://changsikkwon.github.io/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/array</id><content type="html" xml:base="https://changsikkwon.github.io/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/array/">&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;가장 큰 특징은 순차적으로 데이터를 저장한다는 것이다.&lt;/li&gt;
  &lt;li&gt;주로 서로 연결된 데이터들을 순차적으로 저정할때 사용한다.&lt;/li&gt;
  &lt;li&gt;순서가 상관 없더라도 서로 연결된 데이터들을 저장할때 일반적으로 사용된다.&lt;/li&gt;
  &lt;li&gt;이미 생성된 리스트도 수정 가능하다.&lt;/li&gt;
  &lt;li&gt;동일한 값도 여러번 삽입 가능하다.&lt;/li&gt;
  &lt;li&gt;Multi-dimensional Array(다중차원 배열)이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;내부구조&quot;&gt;내부구조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;순서가 있다보니 당연하 순차적으로 번호를 지정할 수 있다. 이 번호를 index라고 한다.&lt;/li&gt;
  &lt;li&gt;index는 0부터 시작되며 마이너스 부호를 가질 수도 있다. 마이너스 index는 맨 마지막 요소부터 시작한다. 예를 들어 맨 마지막 요소의 index는 -1이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;단점&quot;&gt;단점&lt;/h2&gt;

&lt;h3 id=&quot;1-removing-or-adding-elements&quot;&gt;1. Removing or Adding Elements&lt;/h3&gt;

&lt;p&gt;중간의 특정 요소를 삭제해야 하는 경우&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f9bf4489-a0ff-4b98-b17b-23fe9298f195/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f9bf4489-a0ff-4b98-b17b-23fe9298f195/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;순차적으로 담겨있는 데이터 중 특정 위치에 있는 중간의 요소가 삭제 되는 경우에, 항상 메모리가 순차적으로 이어져있어야 하기 때문에, 삭제된 요소로부터 뒤에 있는 모든 요소들을 앞으로 한칸씩 이동시켜주어야 한다.&lt;/p&gt;

&lt;p&gt;그러므로 배열에서 요소를 삭제하는 것은 다른 자료구조에 비해 느릴 수 있다.&lt;/p&gt;

&lt;p&gt;요소를 삭제하는 과정이 코드 상에서는 한 줄 이지만 실제 메모리 상에서 이루어지는 작업은 훨씬 커진다.&lt;/p&gt;

&lt;p&gt;중간에 요소가 추가 되는 경우도 마찬가지이다. 특정 위치에 새롭게 요소가 추가되는 경우에는 그 뒤의 요소들이 하나씩 밀리게 된다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 Array는 정보가 자주 삭제 되거나 추가되는 데이터를 담기에는 적절치 않다.&lt;/p&gt;

&lt;h3 id=&quot;2-array-resizing&quot;&gt;2. Array Resizing&lt;/h3&gt;

&lt;p&gt;배열은 메모리가 순차적으로 채워지기 때문에 배열이 처음 생성될 때 어느정도 메모리를 미리 할당한다.&lt;/p&gt;

&lt;p&gt;메모리를 할당 함으로써 새로 추가되는 요소들도 순차적으로 메모리에 저장될 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 요소들이 처음 할당한 메모리 이상으로 많아지면 resizing이 필요하다.&lt;/p&gt;

&lt;p&gt;즉 메모리를 추가 할당해야한다. 그리고 추가적으로 할당된 메모리 또한 순차적이어야 하기때문에 resizing은 오래걸리는 작업이다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 Array는 사이즈 예측이 잘 안되는 데이터를 다루기에 적절치 않다.&lt;/p&gt;</content><author><name>권창식</name><email>kcs15987@gmail.com</email></author><category term="자료구조" /><category term="Data Structure" /><category term="자료구조" /><category term="Data Structure" /><summary type="html">특징</summary></entry><entry><title type="html">자료구조란?</title><link href="https://changsikkwon.github.io/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/what-is-data-structure/" rel="alternate" type="text/html" title="자료구조란?" /><published>2021-02-25T00:00:00+09:00</published><updated>2021-02-25T00:00:00+09:00</updated><id>https://changsikkwon.github.io/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/what-is-data-structure</id><content type="html" xml:base="https://changsikkwon.github.io/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/data%20structure/what-is-data-structure/">&lt;ul&gt;
  &lt;li&gt;자료구조란 데이터에 편리하게 접근하고 조작하기 위한 데이터를 저장하거나 조직하는 방법이다.&lt;/li&gt;
  &lt;li&gt;자료구조의 종류에는 여라가지가 있습니다. 하지만 모든 목적에 부합하는 자료구조는 없다. 따라서 각각의 자료구조가 갖는 장점과 한계를 잘 이해하고 상황에 맞게 올바른 자료구조를 선택하고 사용하는 것이 중요하다.&lt;/li&gt;
  &lt;li&gt;자료구조는 언어별로 지원하는 양상이 다르다.&lt;/li&gt;
  &lt;li&gt;각 언어가 가진 자료구조의 종류와 그것에 대한 사용 방법을 익히는 것이 중요하지만, 무엇보다 각 자료구조의 본질과 컨셉을 이해하고 상황에 맞는 적절한 자료 구조를 선택하는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료구조의-분류&quot;&gt;자료구조의 분류&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;&lt;strong&gt;Primitive Data Structure(단순 구조)&lt;/strong&gt;&lt;/dt&gt;
      &lt;dd&gt;프로그래밍에서 사용되는 기본 데이터 타입&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;&lt;strong&gt;None-Primitive Data Structure(비단순 구조)&lt;/strong&gt;&lt;/dt&gt;
      &lt;dd&gt;단순한 데이터를 저장하는 구조가 아니라 &lt;strong&gt;여러 데이터를 목적에 맞게 효과적으로 저장하는 자료 구조&lt;/strong&gt; - &lt;strong&gt;Linear Data Structure(선형 구조)&lt;/strong&gt;&lt;/dd&gt;
      &lt;dd&gt;저장되는 자료의 전후 관계가 1:1 (ex. List, Stacks, Queues) - &lt;strong&gt;Non-Linear Data Structure(비선형 구조)&lt;/strong&gt;&lt;/dd&gt;
      &lt;dd&gt;데이터 항목 사이의 관계가 1:n 또는 n:m (ex. Graphs, Trees )&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>권창식</name><email>kcs15987@gmail.com</email></author><category term="자료구조" /><category term="Data Structure" /><category term="자료구조" /><category term="Data Structure" /><summary type="html">자료구조란 데이터에 편리하게 접근하고 조작하기 위한 데이터를 저장하거나 조직하는 방법이다. 자료구조의 종류에는 여라가지가 있습니다. 하지만 모든 목적에 부합하는 자료구조는 없다. 따라서 각각의 자료구조가 갖는 장점과 한계를 잘 이해하고 상황에 맞게 올바른 자료구조를 선택하고 사용하는 것이 중요하다. 자료구조는 언어별로 지원하는 양상이 다르다. 각 언어가 가진 자료구조의 종류와 그것에 대한 사용 방법을 익히는 것이 중요하지만, 무엇보다 각 자료구조의 본질과 컨셉을 이해하고 상황에 맞는 적절한 자료 구조를 선택하는 것이 중요하다.</summary></entry><entry><title type="html">JSX</title><link href="https://changsikkwon.github.io/react/JSX/" rel="alternate" type="text/html" title="JSX" /><published>2021-02-24T00:00:00+09:00</published><updated>2021-02-24T00:00:00+09:00</updated><id>https://changsikkwon.github.io/react/JSX</id><content type="html" xml:base="https://changsikkwon.github.io/react/JSX/">&lt;h2 id=&quot;jsx&quot;&gt;JSX&lt;/h2&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;Hi&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 문법은 JSX라고 불리는 JS 확장버전이다. syntax extension for JS라고 한다. HTML과 아주 비슷하게 생겼고 JS 파일 내에서 작성할 수 있다.&lt;/p&gt;

&lt;p&gt;JSX는 원래의 JS 문법이 아니기 때문에, JS 파일내에 JSX 문법이 있으면 브라우저에서 해석하지 못한다.&lt;/p&gt;

&lt;p&gt;React.js를 사용하기 위해 JSX 문법이 포함되어 있으면, 해당 파일을 정규 JS 문법으로 변환시키는 컴파일 과정이 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;jsx-element&quot;&gt;JSX element&lt;/h2&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;Hi&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myFavorite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;food&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;샐러드&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;dog&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;hobbyL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;programming&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;jsx-attribute&quot;&gt;JSX attribute&lt;/h2&gt;

&lt;p&gt;태그에 속성을 주고 싶을 때는 항상 ““로 감싸야한다.&lt;/p&gt;

&lt;p&gt;예를 들어, class를 주고 싶을 때 원래 속성명은 class이지만 JSX에서는 className을 사용해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&amp;gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myFavorite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;food&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;샐러드&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;dog&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;hobby&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list-item&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;programming&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;self-closing-tag&quot;&gt;Self-Closing Tag&lt;/h3&gt;

&lt;p&gt;JSX에서는 어떤 태그라도 self closing tag가 항상 가능하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;input&amp;gt;&lt;/code&gt;과 같이 하나의 태그가 요소인 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;input /&amp;gt;&lt;/code&gt;과 같이 항상 /로 끝내줘야한다.&lt;/p&gt;

&lt;h2 id=&quot;nested-jsx&quot;&gt;Nested JSX&lt;/h2&gt;

&lt;p&gt;중첩된 요소로 만들려면 ()로 감싸야한다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;good&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;hi&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 제일 처음 요소가 sibling이면 안된다. 무조건 하나의 태그로 감싸저야 한다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;wrong&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;list1&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;list2&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 잘못된 코드&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;list1&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;list2&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 맞는 코드&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;rendering&quot;&gt;Rendering&lt;/h2&gt;

&lt;p&gt;html 요소, 또는 React 요소 등의 코드가 눈으로 볼 수 있도록 그려지는 것을 Rendering 이라고 말한다.&lt;/p&gt;

&lt;p&gt;React 요소가 DOM node에 추가되어 화면에 렌더되려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactDOM.render&lt;/code&gt; 함수를 사용한다.&lt;/p&gt;

&lt;p&gt;첫 번째 인자에는 JSX로 React 요소를 인자로 넘기고, 두 번째 인자는 해당 요소를 렌더하고 싶은 container를 전달한다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;ReactDOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;Hello, world!&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementbyID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>권창식</name><email>kcs15987@gmail.com</email></author><category term="React" /><category term="React" /><summary type="html">JSX</summary></entry><entry><title type="html">Linux</title><link href="https://changsikkwon.github.io/os/Linux/" rel="alternate" type="text/html" title="Linux" /><published>2021-02-24T00:00:00+09:00</published><updated>2021-02-24T00:00:00+09:00</updated><id>https://changsikkwon.github.io/os/Linux</id><content type="html" xml:base="https://changsikkwon.github.io/os/Linux/">&lt;p&gt;Linux는 1991년 Linus Tovals가 개발한 운영체제 이다. Linux는 오픈소스이며 누구나 코드를 볼 수 있다.&lt;/p&gt;

&lt;p&gt;Linux는 시스템을 운영하는데 가장 널리 사용되는 운영체제이다. Windows 시스템이나 application이 아닌 일반적으로 시스템 서버는 Linux 기반으로 운영되고있다.&lt;/p&gt;

&lt;p&gt;Linux는 Windows처럼 일반인을 위한 운영체제가 아니기 때문에 익숙치 않으면 Linux 사용이 많이 어려울 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux Directory Structure&lt;/li&gt;
  &lt;li&gt;PATH&lt;/li&gt;
  &lt;li&gt;Configs&lt;/li&gt;
  &lt;li&gt;Shell Commands&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linux-file-system-hierarchy-fhs&quot;&gt;Linux File System Hierarchy (FHS)&lt;/h2&gt;

&lt;p&gt;Linux의 파일 구조는 다음과 같은 tree 형태로 되어있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://media.vlpt.us/images/kcs15987/post/79e43cfa-c1ca-4bcd-94a4-c53878e84581/image.png&quot; alt=&quot;https://media.vlpt.us/images/kcs15987/post/79e43cfa-c1ca-4bcd-94a4-c53878e84581/image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FHS&lt;/code&gt;의 가장 위에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt; 디렉토리가 있다. Root 디렉토리라고 한다.시작점인 root 디렉토리 안에 여러 하위 디렉토리들이 있고 각 하위 디렉토리들 안에 또 하위 디렉토리 들이 있는 식이다. 각 디렉토리들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt;로 구분한다.&lt;/p&gt;

&lt;h3 id=&quot;home-directory&quot;&gt;Home Directory&lt;/h3&gt;

&lt;p&gt;Linux file system에는 여러 디렉토리가 있지만 그 중 가장 중요하고 기본이 되는 디렉토리는 바로 home 디렉토리이다. 왜냐하면 home 디렉토리가 유저의 공간이기 때문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mac에서는 /home 디렉토리가 아니라 /Users 디렉토리에 유저의 home 디렉토리가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;path&quot;&gt;Path&lt;/h3&gt;

&lt;p&gt;디렉토리 경로에는 2가지 유형이 있는데 absolute path와 relative path이다.&lt;/p&gt;

&lt;h3 id=&quot;absolute-path&quot;&gt;Absolute Path&lt;/h3&gt;

&lt;p&gt;이름 그대로 절대경로이다. Absolute Path는 root 디렉토리에서 부터 시작하는 경로를 뜻한다.root 디렉토리에서 부터 시작하기 때문에 현재 나의 위치아 상관없이 항상 정확히 해당 경로로 이동 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;relative-path&quot;&gt;Relative Path&lt;/h3&gt;

&lt;p&gt;이름 그대로 상대경로이다. absolute path와는 다르게 현재 내 위치를 기반으로 움직이는 경로이다.경로를 이야기 할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;은 현재 디렉토리를 이야기한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;..&lt;/code&gt;은 현재 디렉토리의 상위 디렉토리를 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;configs&quot;&gt;Configs&lt;/h3&gt;

&lt;p&gt;Config fileLinux에는 설정을 주로 파일을 통해서 한다. 그리고 여러 config file, 즉 여러 설정 파일들이 있다. 그 중 가장 중요한 설정 파일이 바로 shell 설정 파일이다. 각 shell마다 고유 설정 파일이 있다. Bash는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; 라는 설정 파일을 사용하고 zsh는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.zshrc&lt;/code&gt;라는 설정 파일을 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;shell-commands&quot;&gt;Shell Commands&lt;/h3&gt;

&lt;h3 id=&quot;basic-shell-commands&quot;&gt;Basic Shell Commands&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;cd = 해당 경로로 이동&lt;/li&gt;
  &lt;li&gt;ls = 현재 디렉토리 안의 파일 목록을 보여줌&lt;/li&gt;
  &lt;li&gt;mv = 원본이동&lt;/li&gt;
  &lt;li&gt;cp = 원본복사&lt;/li&gt;
  &lt;li&gt;cat = 파일 여러개의 내용을 화면에 출력할 때 이용&lt;/li&gt;
  &lt;li&gt;more = 파일을 읽어 화면에 화면 단위로 끊어서 출력&lt;/li&gt;
  &lt;li&gt;less = 한 번에 보여지는 만큼만 읽어서 출력하기 때문에 대용량의 파일을 열어 볼 때 빠르게 사용&lt;/li&gt;
  &lt;li&gt;tail = 파일의 내용을 뒤에서부터 출력&lt;/li&gt;
  &lt;li&gt;nohup = 터미널이 끊겨도 실행한 프로세스는 계속 동작하게 한다.&lt;/li&gt;
  &lt;li&gt;rm = 원복 삭제&lt;/li&gt;
  &lt;li&gt;mkdir = 폴더 생성&lt;/li&gt;
  &lt;li&gt;touch = 파일 생성&lt;/li&gt;
  &lt;li&gt;kill = 프로세서 강제종료&lt;/li&gt;
  &lt;li&gt;clear = 지난 화면 지우기&lt;/li&gt;
  &lt;li&gt;pwd = 현재 디렉토리 경로를 표시&lt;/li&gt;
  &lt;li&gt;chown = 파일의 owner 또는 group을 변경&lt;/li&gt;
  &lt;li&gt;chmod = 대상 파일과 디렉토리의 사용권한을 변경할 때 사용&lt;/li&gt;
  &lt;li&gt;grep = 파일 안 내용찾기&lt;/li&gt;
  &lt;li&gt;history = 그동안 사용자가 입력한 모든 터미널 명령어를 보여줌&lt;/li&gt;
  &lt;li&gt;ps = 현재 실행중인 모든 프로세서 표시&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;piping&quot;&gt;piping&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;pipe라고한다.&lt;/li&gt;
      &lt;li&gt;pipe는 일반적인 명령어가 아니라 명령어를 이어주는 역할을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>권창식</name><email>kcs15987@gmail.com</email></author><category term="Os" /><category term="Os" /><summary type="html">Linux는 1991년 Linus Tovals가 개발한 운영체제 이다. Linux는 오픈소스이며 누구나 코드를 볼 수 있다.</summary></entry><entry><title type="html">Os란?</title><link href="https://changsikkwon.github.io/os/what-is-os/" rel="alternate" type="text/html" title="Os란?" /><published>2021-02-24T00:00:00+09:00</published><updated>2021-02-24T00:00:00+09:00</updated><id>https://changsikkwon.github.io/os/what-is-os</id><content type="html" xml:base="https://changsikkwon.github.io/os/what-is-os/">&lt;p&gt;Operating System의 약자로 사용자가 컴퓨터를 쉽게 다룰 수 있게 해주는 인터페이스이다.&lt;br /&gt;
개인뿐 아니라 업무용 서버 등의 컴퓨터를 관리하고 제어하며, 컴퓨터를 작동시키기 위한 토대를 만드는 소프트웨어를 말한다.&lt;/p&gt;

&lt;h2 id=&quot;os의-종류&quot;&gt;OS의 종류&lt;/h2&gt;

&lt;p&gt;OS의 종류에는 Window, UNIX, LINUX, MS-DOS등이 있다.&lt;br /&gt;
단일 작업 처리 시스템에는 DOS, 다중 작업 처리 시스템에는 Windows, UNIX, LINUX등이 사용된다.&lt;br /&gt;
주로 Windows는 개인용 UNIX, LINUX는 서버용 운영체제로 사용된다.&lt;/p&gt;

&lt;h2 id=&quot;os의-목적&quot;&gt;OS의 목적&lt;/h2&gt;

&lt;p&gt;OS의 목적에는 처리능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등이 있다.&lt;br /&gt; 처리능력, 반환시간, 사용가능도, 신뢰도는 OS의 성능을 평가하는 기준이 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;처리능력&lt;/p&gt;

    &lt;p&gt;일정 시간 내에 시스템이 처리하는 일의 양&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반환시간&lt;/p&gt;

    &lt;p&gt;시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용가능도&lt;/p&gt;

    &lt;p&gt;시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;신뢰도&lt;/p&gt;

    &lt;p&gt;시스템이 주어진 문제를 정확하게 해결하는 정도&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;os의-기능&quot;&gt;OS의 기능&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원을 관리한다.&lt;/li&gt;
  &lt;li&gt;자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공한다.&lt;/li&gt;
  &lt;li&gt;사용자와 시스템간의 편리한 인터페이스를 제공한다.&lt;/li&gt;
  &lt;li&gt;시스템의 각종 하드웨어와 네트워크를 관리, 제어한다.&lt;/li&gt;
  &lt;li&gt;데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공한다.&lt;/li&gt;
  &lt;li&gt;시스템의 오류를 검사하고 복구한다.&lt;/li&gt;
  &lt;li&gt;자원 보호 기능을 제공한다.&lt;/li&gt;
  &lt;li&gt;입출력에 대한 보조 기능을 제공한다.&lt;/li&gt;
  &lt;li&gt;가상 계산기 능력을 제공한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;os의-주요-자원관리&quot;&gt;OS의 주요 자원관리&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 관리
    &lt;ol&gt;
      &lt;li&gt;프로세스 스케줄링 및 동기화 관리담당&lt;/li&gt;
      &lt;li&gt;프로세스 생성과 제거, 시작과 정지, 메세지 전달등의 기능 담당&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기억장치 관리&lt;/p&gt;

    &lt;p&gt;프로세스에게 메모리 할당 및 회수 관리 담당&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주변장치 관리&lt;/p&gt;

    &lt;p&gt;입출력 장치 스케줄링 및 전반적인 관리 담당&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파일 관리&lt;/p&gt;

    &lt;p&gt;파일의 생성과 삭제, 변경, 유지 등의 관리 담당&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>권창식</name><email>kcs15987@gmail.com</email></author><category term="Os" /><category term="Os" /><summary type="html">Operating System의 약자로 사용자가 컴퓨터를 쉽게 다룰 수 있게 해주는 인터페이스이다. 개인뿐 아니라 업무용 서버 등의 컴퓨터를 관리하고 제어하며, 컴퓨터를 작동시키기 위한 토대를 만드는 소프트웨어를 말한다.</summary></entry></feed>